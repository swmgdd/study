### 5장: 유사한 코드 융합하기
- 코드를 연구하지 않고도 일부 리팩터링 패턴의 수행이 가능하다는 사실은 상당한 시간을 절약해준다
- 순수한 조건이 중요한 이유 (side effect X)
  - 조건 표현식을 산술법칙에 대입해서 확인하는 작업은 부수효과가 없을때만 적용 가능하다
  - 부수적인 동작은 조건문에서 흔하게 사용하지 않기 때문에 부수적인 동작이 있을 것으로 예상하지 않는다
- 조건을 수학방정식으로 변환하고 단순화한 후 머릿속에서 다시 코드로 바꾸는 과정을 연습하는 것은 현실세계에서 더 복잡한 조건을 단순화해야할 때 유용하다
- 동일한 관계를 다루고 있다고 해서 이름을 맹목적으로 재사용하지 않는 것이 중요하다. 이름은 문맥도 포함해야 한다
- 구현 클래스가 하나밖에 없는 인터페이스는 가독성에 도움이 되지 않는다
- 복잡한 금융 시스템을 조사하더라도 코드의 기존 구조에 내장된 연결들을 발견할 수 있다. 이 방법으로 발견된 일부 연결은 우연의 일치이므로 조심해서 해당 그룹화가 타당한지 자문해봐야한다. 이런 그룹화는 연결되지 않아야 하는 항목을 연결해서 코드의 일부 고약한 버그를 노출시킬 수 있다

### 6장: 데이터 보호
- 푸시 기반 아키텍처에서는 가능한 데이터에 가깝게 연산을 이관하지만, 풀 기반의 아키텍처에서는 데이터를 가져와 중앙에서 연산을 수행한다
- 공통 접사가 암시하는 구조는 해당 메서드와 변수가 공통 접사의 책임을 공유한다는 것을 의미한다. 이런 메서드는 이 공통 책임을 전담하는 별도의 클래스에 있어야 한다
- 생성자를 활용하면 순서 불변속성을 지키는데 효과적이다

### 7장: 컴파일러와의 협업
- 산술연산을 할 때 컴파일러는 크게 도움이 되지 않는다
- 기본값을 제공하지 않음으로써 컴파일러는 개발자가 결정을 내리도록 강제시키는 것이 안전하다
- 컴파일러와 싸우지 말기, 컴파일러를 신뢰하기
  - 컴파일러보다 우리가 더 잘 알고 있다는 비생산적인 생각에서 벗어나 컴파일러가 말하는 것에 세심한 주의를 기울이기
- 경고에 주의를 기울이기

### 독서평
- 조건표현식을 산술법칙으로 단순화하고 다시 코드로 변환한다는 생각이 흥미롭다

### 질문
- 생성자를 활용해 순서 불변속성을 지키는 것이 좋은 방법일까? 갠적으로 사이드 이펙트가 조금 있어보여서 궁금
  - 만약 순서를 지켜야하는 메서드가 여러개라면 어디부터 어디까지 생성자로 포함시키는게 좋을지?
