### 11장 합성과 유연한 설계

- 컴파일 의존성에 속박되지 않고 다양한 방식의 런타임 의존성을 구성할 수 있다는 것이 합성이 제공하는 가장 커다란 장점
- 물론 컴파일타임 의존성과 런타임 의존성의 거리가 멀면 멀수록 설계의 복잡도가 상승하기 때문에 코드를 이해하기 어려워지는 것 역시 사실이다. 하지만 설계는 변경과 유지보수를 위해 존재한다는 사실을 기억하라. 설계는 트레이드오프의 산물이다.

### 12장 다형성

- 상속을 사용하려는 목적이 단순히 코드를 재사용하기 위해서인가? 아니면 클라이언트 관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위해서인가? 첫 번째 질문에 대한 답이 '예'라면 상속을 사용하지 말아야 한다.
- 개방-폐쇄 원칙이 목적이라면 업캐스팅과 동적 메서드 탐색은 목적에 이르는 방법이다.
- 자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청하는 것을 위임이라고 부른다.
- 처리를 요청할 때 self 참조를 전달하지 않는 경우를 포워딩이라고 부른다.
- 자바스크립트에는 클래가 존재하지 않기 때문에 오직 객체들 사이의 메시지 위임만을 이용해 형성을 구현한다. 이것은 객체지 패러다임에서 클래스가 필수 요소가 아니라는 점을 잘 보여준다.

### 13장 서브클래스와 서브 타이핑

- 개념 관점에서 타입이란 공통의 특징을 공유하는 대상들의 분류다.
- 프로그래밍 언어 관점에서 타입이란 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합이다.
- 객체의 타입이란 객체가 수신할 수 있는 메시지의 종류를 정의하는 것이다.
- 객체의 타입을 결정하는 것은 내부의 속성이 아니라 객체가 외부에 제공하는 행동이라는 사실을 기억하라.
- 슈퍼타입과 서브타입 관계에서는 is-a보다 행동 호환성이 중요하다.
- 행동의 호환 여부를 판단하는 기준은 클라이언트의 관점. 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다.
- 서브클래싱과 서브타이핑을 나누는 기준은 상속을 사용하는 목적이다.
    - 자식 클래스가 부모 클래스의 코드를 재사용할 목적으로 상속을 사용했다면 그것은 서브클래싱이다.
    - 부모 클래스의 인스턴스 대신 식 클래스의 인스턴스를 사용할 목적으로 상속을 사용했다면 그것은 서브타이핑이다.
- 클라이언트가 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.

### 14장 일관성 있는 협력

- 개념적으로는 연관돼 있지만 구현 방식에 있어서 제각각일 수 있다. 이런 비일관성은 두가지 상황에서 발목을 잡는다.
    - 새로운 구현을 추가해야하는 상황
    - 기존의 구현을 이해해야하는 상황
- 코드 재사용을 위한 상속은 해롭다. 즉 서브클래싱은 해롭다.
- 변하는 개념을 변하지 않는 개념으로부터 분리하라.
- 변하는 개념을 캡슐화하라.
- 캡슐화는 변하는 어떤 것이든 감추는 것이다.
- 서브타입 캡슐화 -> 변하는 부분을 분리해 타입계층을 만들기.
- 객체 캡슐화 -> 변하지 않는 부분의 일부로 타입계층을 합성

### 15장 디자인 패턴과 프레임워크

- 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 디자인 패턴. 이 목적은 설계를 재사용하는 것
- 프레임워크는 설계와 코드를 함께 재사용하기 위한 것. 이는 애플리케이션의 아키텍처를 구현 코드의 형태로 제공한다.
- 입문자가 빠지기 쉬운 함정은 패턴을 적용하는 컨텍스트의 적절성은 무시한 채 패턴의 구조에만 초점을 맞추는 것이다.
- 의존성 역전 원리에 따라 추상화에만 의존하도록 의존성의 방향을 조정하고 추상화를 경계로 패키지를 분리했기 때문에 세부 사항을 구현한 패키지는 항상 상위 정책을 구현한 패키지에 의존해야 한다.
- 훌륭한 객체지향 설계는 의존성이 역전된 설계라는 점을 강조한다.
  
