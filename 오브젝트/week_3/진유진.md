## 11. 합성과 유연한 설계
- 상속을 제대로 활용하기 위해서는 부모 클래스의 내부 구현에 대해 상세하게 알아야 하기 때문에 자식 클래스와 부모 클래스 사이의 결합도가 높아질 수 밖에 없다 (구현에 대한 결합보다는 인터페이스에 대한 결합이 더 좋다)
- 상속은 부모 클래스 안에 구현된 코드 자체를 재사용하지만 합성은 포함되는 객체의 퍼블릭 인터페이스를 재사용한다
- 상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가해야 하는 경우를 클래스 폭발/조합의 폭발 문제라고 부른다
- 합성은 컴파일타임 관계를 런타임 관계로 변경한다.
- 믹스인은 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법을 가리킨다 (상속은 정적이고 믹스인은 동적이다)

## 12. 다형성
- 상속의 진정한 목적은 코드 재사용이 아니라 다형성을 위한 서브 타입 계층을 구축하는 것이다
- 자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청하는 것을 위임이라고 한다. 위임은 클래스와 인스턴스 간의 차이를 제거한다.
- 객체가 메시지를 수신하면 컴파일러는 self 참조라는 임시 변수를 자동으로 생성한 후 메시지를 수신한 객체를 가리키도록 설정한다

## 13. 서브클래싱과 서브타이핑
- 객체지향 프로그래밍에서 타입을 정의하는 것은 객체의 퍼블릭 인터페이스를 정의하는 것과 동일하다 (타입 내부 속성이 아닌 외부에 제공하는 행동)
- 언제 상속을 사용해야하는가? (아래 질문에 모두 '예'라고 답할 수 있는 경우에만)
  - 상속 관계가 is-a 관계를 모델링하는가?
  - 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
- is-a 관계
  - 어휘적인 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야한다
- 행동 호환 여부를 판단하는 기준은 클라이언트 관점이다. 현실을 정확하게 묘사하는 것이 아니라 요구사항을 실용적으로 수용하는 것을 목표로 삼아야 한다
- 리스코프 치환 원칙은 "클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가능하다"는 중요한 결론을 이끈다

## 14. 일관성 있는 협력
- 유사한 요구사항을 구현하는 서로 다른 구조의 코드는 코드를 이해하는 데 심리적인 장벽을 만든다
- 일관성 있는 설계를 만드는 데 가장 훌륭한 조언은 다양한 설계 경험을 익히라는 것이다
- 클래스를 분리하기 위해 어떤 기준을 따르는 것이 좋을까? 가장 중요한 기준은 변경의 이유와 주기다
- 변하는 개념을 변하지 않는 개념으로부터 분리하라
- 변하는 개념을 캡슐화하라
- 비록 설계를 약간 비트는 것이 조금 이상한 구조를 낳더라도 전체적으로 일관성을 유지할 수있는 설계를 선택하는 것이 현명하다
- 개념적 무결성을 무너뜨리는 것보다는 약간의 부조화를 수용하는 편이 더 낫다

## 15. 디자인 패턴과 프레임워크
- 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수있는 해결 방법을 디자인 패턴이라고 부른다
- 프레임워크는 설계와 코드를 함께 재사용하기 위한 것이다
- 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다
- 패턴은 공통으로 사용할 수 있는 역할, 책임, 협력의 템플릿이다. 패턴의 구성요소는 클래스가 아니라 역할이다
- 디자인 패턴은 단지 역할과 책임, 협력의 템플릿을 제안할 뿐 구체적인 구현 방법에 대해서는 제한을 두지 않는다 => 현재의 요구에 맞게 구조를 수정할 수 있다

## 질문
- 객체지향에서 상속으로 인한 결합도를 해결하기 위해 mixin이 탄생하였다고 하는데 대표적인 객체지향인 java에서 mixin을 도입하지 않는 이유가 무엇이라고 생각하는지?
