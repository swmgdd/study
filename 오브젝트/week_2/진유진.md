### 06. 메시지와 인터페이스
- 좋은 인터페이스란 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야 한다
  - 최소한의 인터페이스: 꼭 필요한 오퍼레이션만을 인터페이스에 포함
  - 추상적인 인터페이스: 어떻게 수행하는지가 아니라 무엇을 하는지를 표현
- 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법 => 결국은 책임에 초점을 맞춰라
  - 디미터 법칙: 객체의 협력 경로를 제환하여 결합도를 효과적으로 낮추는 방법 (기차 충돌은 안티패턴, but 객체의 내부 구현에 대한 어떤 정보도 노출하지 않는 기차충돌이라면 괜춘)
  - 묻지 말고 시켜라: 객체의 상태를 묻지말고 행동을 유도하는 것 (객체에게 자율성을 보장)
  - 의도를 드러내는 인터페이스: 어떻게 하느냐가 아니라 무엇을 하느냐에 따라 메서드 이름 짓기 (매우 다른 두 번째 구현을 상상하여 메서드명의 추상성을 개선할 수 있음)
  - 명령-쿼리 분리: 오퍼레이션을 부수효과를 발생시키는 명령 / 부수효과를 발생시키지 않는 쿼리로 분리 
- 설계는 트레이드오프의 산물이며 적절하게 트레이드오프 할 수 있는 능력이 숙련자와 초보자를 구분하는 기준이다
  - 초보자는 원칙을 맹목적으로 추종한다
  - 원칙을 아는 것보다 더 중요한 것은 원칙이 언제 유용한지 판단할 수 있는 능력을 기르는 것이다
  - 소프트웨어 설계에 존재하는 몇 안 되는 법칙 중 하나는 "경우에 따라 다르다"라는 사실

### 07. 객체분해
- 프로그래밍 패러다임은 (1) 프로그래밍을 구성하기 위해 사용하는 추상화의 종류, (2) 이 추상화를 이용해 소프트웨어를 분해하는 방법의 두 가지 요소로 결정한다
- (전통적 기능 분해 방법) 하향식 접근법
  - 모든 함수는 상위 함수를 분해하는 과정에서 필요에 따라 식별되며, 그에 따라 상위 함수가 강요하는 context 안에서만 의미를 가진다
  - 이미 해결된 알고리즘을 문서화하고 서술하는데는 훌륭하나, 실제로 동작하는 커다란 소프트웨어를 설계하는데 적합한 방법은 아니다
- 모듈
  - 기능이 아니라 변경의 정도에 따라 시스템을 분해하게 한다
  - 정보 은닉이라는 개념을 통해 데이터라는 존재를 설계의 중심 요소로 부각시켰다 (모듈에 있어서 핵심은 데이터)
- 클래스 vs 추상 데이터 타입
  - 추상 데이터 타입은 타입을 추상화한 것
  - 클래스는 절차를 추상화한 것
  - 추상 데이터 타입과 객체지향 설계의 유용성은 설계에 요구되는 변경의 압력이 '타입 추가'에 관한 것인지 아니면 '오퍼레이션 추가'에 관한 것인지에 따라 달라진다

### 08. 의존성 관리하기
- 의존성의 종류는 직접 의존성 / 간접 의존성으로 나뉜다
- 런타입 의존성과 컴파일타임 의존성이 다를 수 있다. 유연하고 재사용 가능한 코드를 설계하기 위해서는 두 종류의 의존성을 서로 다르게 만들어야 한다
- 컨텍스트 독립성: 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다
- 의존성은 명시적으로 표현돼야 한다. 유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계이다
- new를 사용하면 결합도를 높이기 때문에, 인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리하여 해결할 수 있다.
- 구체 클래스에 의존하게 되더라도 클래스의 사용성이 더 중요하다면 결합도를 의도적으로 높일 수 있다 (default type)
- 의존성이 불편한 이유는 그것이 항상 변경에 대한 영향을 암시하기 때문이라 변경될 확률이 거의 없는 클래스라면 의존성이 문제가 되지 않는다 (ex 표준 클래스)
  - but, 의존성에 의한 영향이 적은 경우에도 추상화에 의존하고 의존성을 명시적으로 드러내는 것은 좋은 설계 습관이다 

### 질문
- 많은 원칙들이 소개되면서도 상황에 따라 적합하게 적용해야한다고 이야기를 하는데 대부분의 상황에 적용했을 때 이점을 얻을 수 있는 원칙이 무엇이라고 생각하는지?
- 변경될 확률이 거의 없는 클래스의 기준이 무엇이라고 생각하시나요?
