## 6 메시지와 인터페이스
- 클래스라는 구현 도구에 지나치게 집착하면 경직되고 유연하지 못한 설계에 이를 확률이 높아진다.
- 좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야 한다. 최소한의 인터페이스는 꼭 필요한 오퍼레이션만을 인터페이스에 포함한다. 추상적인 인터페이스는 어떻게 수행하는지가 아니라 무엇을 하는지를 표현한다.
- 디미터법칙: 낮선 자에게 말하지 말라, 오직 인접한 이웃하고만 말하라
- TDA: 묻지 말고 시켜라
- 의도를 드러내는 인터페이스: '어떻게'가 아니라 '무엇'을 하는지를 드러내라.
- 명령-쿼리 분리: 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야만 한다. 어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안된다.

## 7 객체 분해
- 프로시저 추상화 -> 소프트웨어가 무엇을 해야하는지(기능 분해 / 알고리즘 분해)
- 데이터 추상화 -> 소프트웨어가 무엇을 알아야 하는지(타입을 추상화 = 추상 데이터 타입 / 프로시저를 추상화 = 객체지향)
- 클래스는 상속과 다형성을 지원하는데 비해 추상 데이터 타입은 지원하지 못한다는 점이다. 이를 구분하기 위해 객체기반이라고 명명하기도 함.

## 8 의존성 관리하기
- 의존성이 실제로 전이될지 여부는 변경의 방향과 캡슐화의 정도에 따라 달라진다. 이로 인해 직접 / 간접 의존성으로 나누기도 한다.
- 컴파일타임 의존성은 런타임 의존성으로 대체돼야 한다. 이를 의존성 해결이라고 부른다.
- new는 해롭다


## 질문
- 왜 요즘에는 DB에서만 주로 프로시저라는 단어를 사용할까?
- 왜 추상 데이터 타입에서는 상속과 다형성을 지원하지 못했을까?
- 의존성이 없는 함수형 언어는 그럼 좋을까?
